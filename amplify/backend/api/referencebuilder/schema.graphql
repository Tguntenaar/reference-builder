# TODO:
# auth
# user groups admin

type Company
  @model(subscriptions: null)
  @auth(
    rules: [
      # Defaults to use the "owner" field.
      { allow: owner }
      # Authorize the update mutation and both queries.
      # { allow: owner, ownerField: "editors", operations: [update] }
      # Admin users can access any operation.
      { allow: groups, groups: ["Admins"], operations: [create] }
      # { allow: groups, groups: ["Managers", "Employees"], operations: [read] }
      # Each record may specify which groups may read them. (Bijvoorbeeld een company als groep)
      # { allow: groups, groupsField: "groupsCanAccess", operations: [read] }

      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
    ]
  ) {
  id: ID!
  name: String!
  admins: [ID!]
  teams: [Team!] @connection(keyName: "TeamsByCompany", fields: ["id"]) # has many
  group: String!
}

type Team
  @model(subscriptions: null)
  @auth(
    rules: [
      { allow: owner }
      # Admin users can access any operation.
      { allow: groups, groups: ["Admins"], operations: [create] }
      # { allow: owner, ownerField: "adminId", operations: [ create, update ]} # only admin can edit
      # {allow: groups, groupsField: "members", operations: [ read ]}

      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
    ]
  )
  @key(name: "TeamsByCompany", fields: ["companyId", "createdAt"]) { # team has many users
  id: ID!
  createdAt: AWSDateTime
  avatar: S3Object
  name: String!
  admins: [ID!]
  group: String
  companyId: ID!
  company: Company @connection(fields: ["companyId"]) # has one
  membersLink: [TeamMemberLink!]
    @connection(keyName: "usersByTeam", fields: ["id"]) # has many
  skills: [Skill!] @connection(keyName: "skillsByTeam", fields: ["id"]) # has many
  averageRatings: [averageTeamRating]
    @connection(keyName: "averageRatingsByTeam", fields: ["id"]) #has many
}

type TeamMemberLink
  @auth(
    rules: [
      # implicit store of owner
      { allow: owner, operations: [create] }
      # Admin users can access any operation.
      { allow: groups, groups: ["Admins"], operations: [create] }
      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
    ]
  )
  @model(queries: null, subscriptions: null)
  @key(name: "teamsByUser", fields: ["userId", "teamId"])
  @key(name: "usersByTeam", fields: ["teamId", "userId"]) {
  id: ID!
  userId: ID!
  teamId: ID!
  group: String
  user: User @connection(fields: ["userId"])
  team: Team @connection(fields: ["teamId"])
}

type User
  # @auth(rules: [{ allow: owner }, { allow: private, provider: iam }])
  # @auth(rules: [
  #   { allow: owner, ownerField: "id", operations: [create, update, delete]}
  #   ])
  @model(subscriptions: null)
  @auth(
    rules: [
      # implicit store of owner
      { allow: owner, operations: [create] }
      # Admin users can access any operation.
      { allow: groups, groups: ["Admins"], operations: [create] }
      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
    ]
  ) {
  id: ID!
  createdAt: AWSDateTime
  # presentation
  name: String
  email: String
  jobTitle: String
  avatar: S3Object
  activeTeam: TeamMemberLink
  # dashboard
  teamsLink: [TeamMemberLink!]
    @connection(keyName: "teamsByUser", fields: ["id"]) # many to many
  # evaluation requests
  requests: [EvaluationRequest]
    @connection(keyName: "evaluationRequestsByUser", fields: ["id"]) # has many
  receivedRequests: [EvaluationRequest]
    @connection(keyName: "evaluationRequestsByEvaluator", fields: ["id"]) # has many
  # evaluations
  # TODO: fixme het is niet echt many to many want het is 2 to many maar mis wel beter
  evaluations: [Evaluation]
    @connection(keyName: "evaluationsByEvaluator", fields: ["id"]) # has many
  receivedEvaluations: [Evaluation]
    @connection(keyName: "evaluationsByUser", fields: ["id"]) # has many
  averageRatings: [averageUserRating]
    @connection(keyName: "averageRatingsByUser", fields: ["id"]) # has many
  group: String
}

type S3Object {
  bucket: String!
  region: String!
  key: String!
}

# all ratings/skill and a comment
type Evaluation
  @model(subscriptions: null)
  @auth(
    rules: [
      # Only the owner can update and delete
      { allow: owner, operations: [create, update, delete] }
      # Admin users can access any operation.
      { allow: groups, groups: ["Admins"], operations: [create] }
      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
    ]
  )
  @key(
    name: "evaluationsByUser"
    fields: ["userId", "createdAt"]
    queryField: "evaluationsByUser"
  ) # user connection
  @key(name: "evaluationsByEvaluator", fields: ["authorId", "createdAt"]) { # evaluator connection
  id: ID!
  createdAt: AWSDateTime
  # receiver
  userId: ID!
  user: User! @connection(fields: ["userId"]) # belongs to
  # evaluator
  authorId: ID!
  author: User! @connection(fields: ["authorId"]) # belongs to
  # content
  ratings: [Rating!] @connection(keyName: "ratingsByEvaluation", fields: ["id"]) # has many
  comment: String
  group: String
}

# per skill rating
type Rating
  @auth(
    rules: [
      # Only the owner can update and delete
      { allow: owner, operations: [create, update, delete] }
      # Admin users can access any operation.
      { allow: groups, groups: ["Admins"], operations: [create] }
      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
    ]
  )
  @model(subscriptions: null)
  @key(name: "ratingsByEvaluation", fields: ["evaluationId"]) # Evaluation has many ratings
  @key(name: "ratingsBySkill", fields: ["skillId"]) { # TODO: misschien overbodig
  id: ID!
  evaluationId: ID!
  evaluation: Evaluation! @connection(fields: ["evaluationId"]) # has one
  skillId: ID!
  skill: Skill! @connection(fields: ["skillId"]) # has one
  grade: Int
  # comment: String
  group: String
}

# on create skill create average from every user in team
type averageUserRating
  @auth(
    rules: [
      # Implicit store of owner
      { allow: owner, operations: [create] }
      # Admin users can access any operation.
      { allow: groups, groups: ["Admins"], operations: [create] }
      # Lambda function
      { allow: private, provider: iam }
    ]
  )
  @model(subscriptions: null)
  @key(name: "averageRatingsByUser", fields: ["userId", "skillId"]) {
  # Team or Skill
  id: ID!
  userId: ID!
  user: User! @connection(fields: ["userId"]) # has one
  skillId: ID!
  skill: Skill! @connection(fields: ["skillId"]) # has one
  grade: Int!
  timesRated: Int!
}

# on create skill create average
type averageTeamRating
  # TODO: iam role
  @auth(
    rules: [
      # implicit store of owner
      { allow: owner }
      # Lambda function
      { allow: private, provider: iam }
    ]
  )
  @model(subscriptions: null)
  @key(name: "averageRatingsByTeam", fields: ["teamId", "skillId"]) {
  # Team or Skill
  id: ID!
  teamId: ID!
  team: Team! @connection(fields: ["teamId"]) # has one
  skillId: ID!
  skill: Skill! @connection(fields: ["skillId"]) # has one
  grade: Int!
  timesRated: Int!
}

type Skill
  @auth(
    rules: [
      # implicit store of owner
      { allow: groups, groups: ["Admins", "Managers"], operations: [create] }
      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
    ]
  )
  @model(subscriptions: null)
  @key(name: "skillsByTeam", fields: ["teamId"]) { # team has many skills
  id: ID!
  teamId: ID!
  name: String!
  description: String
  forManager: Boolean
  active: Boolean
  group: String
}

# TODO: binnen een team alleen zichtbaar?
type EvaluationRequest  # message
  @model
  @auth(
    rules: [
      # implicit store of owner
      { allow: owner, operations: [create] }
      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
    ]
  )
  # @auth(rules: [
  #   { allow: owner, ownerField: "evaluatorId", operations: [ create, delete ]},
  # ])
  @key(
    name: "evaluationRequestsByEvaluator"
    fields: ["evaluatorId", "createdAt"]
  ) # connection with user
  @key(name: "evaluationRequestsByUser", fields: ["userId", "createdAt"]) { # connection with user
  id: ID!
  createdAt: AWSDateTime
  evaluatorId: ID!
  evaluator: User! @connection(fields: ["evaluatorId"]) # belongs to
  userId: ID!
  user: User! @connection(fields: ["userId"]) # belongs to
  status: EvaluationStatus!
  group: String
}

enum EvaluationStatus {
  PENDING
  REVIEWED
}
