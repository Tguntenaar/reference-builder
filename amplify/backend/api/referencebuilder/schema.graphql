# TODO:
# auth
# user groups admin

type Company
  @model(subscriptions: null)
  @auth(
    rules: [
      # implicit store of owner
      # { allow: owner }
      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
      # Allow for API key
      { allow: public }
    ]
  ) {
  id: ID!
  name: String!
  admins: [ID!]
  teams: [Team!] @connection(keyName: "TeamsByCompany", fields: ["id"]) # has many
  group: String!
  colors: Colors
}

type Colors
  @model(subscriptions: null)
  @auth(
    rules: [
      # implicit store of owner
      # { allow: owner }
      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
      # Allow for API key
      { allow: public }
    ]
  ) {
  id: ID!
  primary: String!
  secondary: String!
  rating1: String!
  rating2: String!
  rating3: String!
  gradientStart: String!
  gradientEnd: String!
}

type Team
  @model(subscriptions: null)
  @auth(
    rules: [
      # implicit store of owner
      # { allow: owner }
      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
      # Allow for API key
      { allow: public }
    ]
  )
  @key(name: "TeamsByCompany", fields: ["companyId", "createdAt"]) { # team has many users
  id: ID!
  createdAt: AWSDateTime
  avatar: S3Object
  name: String!
  admins: [ID!]
  group: String
  active: Boolean # TODO: moet deze wel gebruikt worden?
  companyId: ID!
  company: Company @connection(fields: ["companyId"]) # has one
  membersLink: [TeamMemberLink!]
    @connection(keyName: "usersByTeam", fields: ["id"]) # has many
  skills: [Skill!] @connection(keyName: "skillsByTeam", fields: ["id"]) # has many
  averageRatings: [averageTeamRating]
    @connection(keyName: "averageRatingsByTeam", fields: ["id"]) #has many
}

# TODO: list team member links en check of elke een group heeft
type TeamMemberLink
  @auth(
    rules: [
      # implicit store of owner
      # { allow: owner }
      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
      # Allow for API key
      { allow: public }
    ]
  )
  @model(subscriptions: null)
  @key(name: "teamsByUser", fields: ["userId", "teamId"])
  @key(name: "usersByTeam", fields: ["teamId", "userId"]) {
  id: ID!
  userId: ID!
  teamId: ID!
  group: String
  user: User @connection(fields: ["userId"])
  team: Team @connection(fields: ["teamId"])
  active: Boolean
}

type User
  @model(subscriptions: null)
  @auth(
    rules: [
      # implicit store of owner
      # { allow: owner }
      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
      # Allow for API key
      { allow: public }
    ]
  ) {
  id: ID!
  createdAt: AWSDateTime
  # presentation
  name: String
  email: String
  jobTitle: String
  avatar: S3Object
  # TODO: active team id is niet het team id maar de team link id
  activeTeamID: ID!
  activeTeam: TeamMemberLink @connection(fields: ["activeTeamID"]) # has one
  # dashboard
  teamsLink: [TeamMemberLink!]
    @connection(keyName: "teamsByUser", fields: ["id"]) # many to many
  # evaluation requests
  requests: [EvaluationRequest]
    @connection(keyName: "evaluationRequestsByUser", fields: ["id"]) # has many
  receivedRequests: [EvaluationRequest]
    @connection(keyName: "evaluationRequestsByEvaluator", fields: ["id"]) # has many
  # evaluations
  evaluations: [Evaluation]
    @connection(keyName: "evaluationsByEvaluator", fields: ["id"]) # has many
  receivedEvaluations: [Evaluation]
    @connection(keyName: "evaluationsByUser", fields: ["id"]) # has many
  averageRatings: [averageUserRating]
    @connection(keyName: "averageRatingsByUser", fields: ["id"]) # has many
  group: String
}

type S3Object {
  bucket: String!
  region: String!
  key: String!
}

# all ratings/skill and a comment
type Evaluation
  @model(subscriptions: null)
  @auth(
    rules: [
      # implicit store of owner
      # { allow: owner }
      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
      # Allow for API key
      { allow: public }
    ]
  )
  @key(
    name: "evaluationsByUser"
    fields: ["userId", "createdAt"]
    queryField: "evaluationsByUser"
  ) # user connection
  @key(name: "evaluationsByEvaluator", fields: ["authorId", "createdAt"]) { # evaluator connection
  id: ID!
  createdAt: AWSDateTime
  # receiver
  userId: ID!
  user: User! @connection(fields: ["userId"]) # belongs to
  # evaluator
  authorId: ID!
  author: User! @connection(fields: ["authorId"]) # belongs to
  # content
  ratings: [Rating!] @connection(keyName: "ratingsByEvaluation", fields: ["id"]) # has many
  comment: String
  group: String
}

# per skill rating
type Rating
  @auth(
    rules: [
      # implicit store of owner
      # { allow: owner }
      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
      # Allow for API key
      { allow: public }
    ]
  )
  @model(subscriptions: null)
  @key(name: "ratingsByEvaluation", fields: ["evaluationId"]) # Evaluation has many ratings
  @key(name: "ratingsBySkill", fields: ["skillId"]) {
  id: ID!
  evaluationId: ID!
  evaluation: Evaluation! @connection(fields: ["evaluationId"]) # has one
  skillId: ID!
  skill: Skill! @connection(fields: ["skillId"]) # has one
  grade: Int
  # comment: String
  group: String
}

# on create skill create average from every user in team
type averageUserRating
  @auth(
    rules: [
      # implicit store of owner
      # { allow: owner }
      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
      # Allow for API key
      { allow: public }
    ]
  )
  @model(subscriptions: null)
  @key(name: "averageRatingsByUser", fields: ["userId", "skillId"]) {
  # Team or Skill
  id: ID!
  userId: ID!
  user: User! @connection(fields: ["userId"]) # has one
  skillId: ID!
  skill: Skill! @connection(fields: ["skillId"]) # has one
  grade: Int!
  timesRated: Int!
}

# on create skill create average
type averageTeamRating
  @auth(
    rules: [
      # implicit store of owner
      # { allow: owner }
      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
      # Allow for API key
      { allow: public }
    ]
  )
  @model(subscriptions: null)
  @key(name: "averageRatingsByTeam", fields: ["teamId", "skillId"]) {
  # Team or Skill
  id: ID!
  teamId: ID!
  team: Team! @connection(fields: ["teamId"]) # has one
  skillId: ID!
  skill: Skill! @connection(fields: ["skillId"]) # has one
  grade: Int!
  timesRated: Int!
  group: String
}

type Skill
  @auth(
    rules: [
      # implicit store of owner
      # { allow: owner }
      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
      # Allow for API key
      { allow: public }
    ]
  )
  @model(subscriptions: null)
  @key(name: "skillsByTeam", fields: ["teamId"]) { # team has many skills
  id: ID!
  teamId: ID!
  name: String!
  description: String
  forManager: Boolean
  active: Boolean
  group: String
}

type EvaluationRequest
  @model
  @auth(
    rules: [
      # implicit store of owner
      # { allow: owner }
      # Dynamic group authorization with a single group
      { allow: groups, groupsField: "group" }
      # Allow for API key
      { allow: public }
    ]
  )
  @key(
    name: "evaluationRequestsByEvaluator"
    fields: ["evaluatorId", "createdAt"]
  ) # connection with user
  @key(name: "evaluationRequestsByUser", fields: ["userId", "createdAt"]) { # connection with user
  id: ID!
  createdAt: AWSDateTime
  evaluatorId: ID!
  evaluator: User! @connection(fields: ["evaluatorId"]) # belongs to
  userId: ID!
  user: User! @connection(fields: ["userId"]) # belongs to
  status: EvaluationStatus!
  group: String
}

enum EvaluationStatus {
  PENDING
  REVIEWED
}
